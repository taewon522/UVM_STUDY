## DUT

![image.png](attachment:fde4821b-552e-4a13-a903-51eb02f7c21b:image.png)

- half adder를 기반으로 설계

![image.png](attachment:adba18ad-24cc-4fa2-a0b1-78c9a56922f4:image.png)

- clk에 동기화해서 출력

![image.png](attachment:189dbe42-6c1b-4ca2-a8ee-c65b47ae6f2a:image.png)

---

## UVM hierarchy

![image.png](attachment:33b8a589-f661-4039-a4be-16488ca76d46:image.png)

- dut가 커지면 포트를 나눠서 agent를 늘릴수있다.
- Virtual Sequence가 Virtual Sequencer 위에서 실행된다
    - **Virtual Sequence가 Sub-sequencer와 Virtual Interface를 찾기 위해서** Virtual Sequencer의 지도가 필요하기 때문에

### 1. 언제 연결되는가? (`start` 메서드)

Test(최상위) 계층에서 시퀀스를 실행할 때, 인자로 시퀀서를 넘겨주면서 연결이 성립된다.

```verilog
// Test Class의 run_phase 내부
task run_phase(uvm_phase phase);
    my_virtual_seq v_seq; 
    
    v_seq = my_virtual_seq::type_id::create("v_seq");
    
    // [중요] 여기서 연결됨!
    // "v_seq야, 너는 env.v_seqr 위에서 동작해라"라고 지정함.
    v_seq.start(env.v_seqr); 
endtask
```

![image.png](attachment:528848dc-0a61-4897-8148-492d9b73ebf2:image.png)

### 작동 원리 (Implicit Start)

UVM 프레임워크는 `run_phase`가 시작될 때, 해당 시퀀서에 `default_sequence`가 설정되어 있는지 확인한다.
설정되어 있다면, **UVM이 알아서(내부적으로) `start()`를 호출해준다.**

즉, 직접 `v_seq.start(env.v_seqr)`를 치지 않아도, UVM이 백그라운드에서 똑같은 작업을 대신 수행해주는 것이다.

### 2. 연결되면 무슨 일이 일어나는가? (`p_sequencer`)

`start(env.v_seqr)`가 호출되는 순간, Virtual Sequence 내부에 있는 `p_sequencer`라는 핸들이 자동으로 `env.v_seqr`를 가리키게 된다.

이 연결 덕분에 `adder_vif`나 하위 시퀀서(`adder_seqr`)에 접근할 수 있게 된다.

**[Virtual Sequence 내부 코드]**

```verilog
class my_virtual_seq extends uvm_sequence;
  `uvm_object_utils(my_virtual_seq)
  
  // [매크로] vseqr_c 타입의 p_sequencer 변수를 선언함
  `uvm_declare_p_sequencer(vseqr_c) 

  task body();
    // 연결되었으므로 p_sequencer를 통해 시퀀서 내부 변수에 접근 가능
    
    // 1. 아까 질문한 Virtual Interface 접근
    wait(p_sequencer.adder_vif.rstn == 1); 

    // 2. 하위 시퀀서 핸들 접근
    sub_seq.start(p_sequencer.adder_seqr); 
  endtask
endclass
```

![image.png](attachment:c3fb9e5a-6818-4a9a-b18a-7f1d482475fa:image.png)

![image.png](attachment:8d736a43-ab75-408d-b689-5f0fc6c2d271:image.png)

![image.png](attachment:71985496-d3a3-4106-a0bb-b8c2cecc5947:image.png)

에이전트가 늘어나면 버추얼 시퀀서는 모든 하위 시퀀서들의 핸들(주소)을 다 가지고 있어야 한다.

이를 통해 버추얼 시퀀스는 **"중앙 관제탑"** 역할을 수행하며, 상황에 따라 A 에이전트에게 일을 시킬지, B 에이전트에게 일을 시킬지, 아니면 둘 다 동시에 시킬지를 결정한다.

구조를 3단계로 나누어 정리한다.

### 1. Virtual Sequencer: 모든 연락처(Handle) 선언

에이전트가 3개(APB, AHB, UART)라고 가정하면, 버추얼 시퀀서 안에는 3개의 변수가 있어야 한다.

```verilog
class vseqr_c extends uvm_sequencer;
  `uvm_component_utils(vseqr_c)

  // 각 에이전트의 시퀀서를 가리킬 핸들 선언
  apb_sequencer_c  apb_seqr;
  ahb_sequencer_c  ahb_seqr;
  uart_sequencer_c uart_seqr; 
  // + Virtual Interface도 필요하면 여기에 다 선언함

  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction
endclass
```

### 2. Environment: 실제 연결 (Wiring)

`connect_phase`에서 실제 에이전트들이 가진 시퀀서를 버추얼 시퀀서의 변수에 1:1로 매칭해준다.

```verilog
class env_c extends uvm_env;
  // ... (agent 인스턴스들) ...
  vseqr_c v_seqr;

  function void connect_phase(uvm_phase phase);
    // 각 에이전트의 시퀀서를 버추얼 시퀀서 핸들에 연결
    v_seqr.apb_seqr  = apb_agent.sequencer;
    v_seqr.ahb_seqr  = ahb_agent.sequencer;
    v_seqr.uart_seqr = uart_agent.sequencer;
  endfunction
endclass
```

### 3. Virtual Sequence: 선택 및 실행 (Selection Logic)

이제 시퀀스 내부에서 조건(if/case)이나 **순서**에 따라 원하는 시퀀서를 골라 `start()`를 건다. 네가 말한 "신호(변수)"를 통해 제어하는 것이 바로 이 부분이다.

```verilog
class my_full_vseq extends uvm_sequence;
  `uvm_object_utils(my_full_vseq)
  `uvm_declare_p_sequencer(vseqr_c) // 위에서 만든 vseqr_c 참조

  rand int mode; // 0: APB only, 1: All Parallel

  task body();
    if (mode == 0) begin
       // APB 시퀀서만 선택해서 실행
       apb_seq.start(p_sequencer.apb_seqr);
    end
    else begin
       // fork-join으로 3개 시퀀서 동시 실행
       fork
         apb_seq.start(p_sequencer.apb_seqr);
         ahb_seq.start(p_sequencer.ahb_seqr);
         uart_seq.start(p_sequencer.uart_seqr);
       join
    end
  endtask
endclass
```

### 요약

1. **선언:** 버추얼 시퀀서에 `seqr1`, `seqr2`, `seqr3`... 처럼 다 선언한다.
2. **연결:** Env에서 실제 에이전트의 시퀀서를 꽂아준다.
3. **선택:** 버추얼 시퀀스에서 로직(if문 등)을 짜서, `p_sequencer.seqr1`에 보낼지 `p_sequencer.seqr2`에 보낼지 결정한다.

![image.png](attachment:ff0fe867-8ee6-4af1-b542-a821e11bd578:image.png)

- 시퀀스 위주로 작성

![image.png](attachment:c06c348c-f55e-49d2-8a83-9f64a855419a:image.png)

![image.png](attachment:ae30c5ae-b9b0-49d9-95ad-2f17a5e7414f:image.png)

![image.png](attachment:bbff1355-e662-4635-a851-4f9fe945e0c1:image.png)

![image.png](attachment:6b85107d-f259-4bd4-a7c8-e180cae285f3:image.png)

- mian은 시퀀스 스코어보드, 모니터를 바꾸는것

![image.png](attachment:def00343-a111-43a5-b34b-aa872012e425:image.png)

![image.png](attachment:592d773d-adc1-4986-9108-4cb7e8719ac4:image.png)

![image.png](attachment:7785af04-8dfd-4893-b75c-d4b78e2b416e:image.png)

- 모니터에서 타이밍 조정
- 스코어보드에서는 비교만
